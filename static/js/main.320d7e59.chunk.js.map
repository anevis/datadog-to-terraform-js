{"version":3,"sources":["convertor/dashboard/ConditionalFormat.ts","convertor/dashboard/BaseComponent.ts","convertor/dashboard/Widget.ts","convertor/dashboard/Request.ts","convertor/dashboard/Dashboard.ts","convertor/formatter.ts","components/App.tsx","serviceWorker.ts","index.tsx"],"names":["Comparator","BaseComponent","ddJson","options","this","initOptions","opts","Object","keys","opt","hasOwnProperty","propertyNames","includes","optionList","push","optionToTerraform","join","WidgetType","ConditionalFormat","comparator","value","palette","Metadata","expression","aliasName","alias_name","Style","lineType","lineWidth","line_type","line_width","terraformStr","Request","query","conditionalFormat","metadata","style","requestDdJson","undefined","fill","q","initConditionalFormat","initMetadata","initStyle","conditional_formats","map","cfJson","mdJson","optionsToTerraform","metadataToTerraform","styleToTerraform","conditionalFormatToTerraform","optionsStr","length","md","toTerraform","cf","LayoutType","TERRAFORM_DEFINITION","ALERT_GRAPH","FREE_TEXT","GROUP","HOSTMAP","TOPLIST","QUERY_VALUE","TIMESERIES","Layout","x","y","width","height","Time","Widget","definition","type","title","layout","requests","isSupported","widgets","time","widgetJson","values","initLayout","initRequests","initWidgets","validate","Array","rJson","wJson","Error","requestStr","req","layoutStr","widgetsToTerraform","wg","Dashboard","jsonStr","JSON","parse","layoutType","notifyList","layout_type","notify_list","dgWidgetJson","TFPrettier","indent","prettySlr","prevTfChar","curTfChar","inString","bracketLevel","tfStr","tfPos","formatBrackets","formattedStr","getIndent","level","App","props","render","className","htmlFor","id","rows","onChange","onJSONChange","state","error","checked","prettyPrint","onPrettyPrint","text","e","jsonFldStr","target","setState","convert","ddJsonStr","formatter","pretty","err","message","React","PureComponent","Boolean","window","location","hostname","match","ReactDOM","document","getElementById","navigator","serviceWorker","ready","then","registration","unregister"],"mappings":"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","file":"static/js/main.320d7e59.chunk.js","sourcesContent":["export enum Comparator {\n    LESS_THAN = '<',\n    LESS_THAN_OR_EQUAL_TO = '<=',\n    GREATER_THAN = '>',\n    GREATER_THAN_OR_EQUAL_TO = '>=',\n    EQUAL_TO = '='\n}\n\nexport class ConditionalFormat {\n    public readonly comparator: Comparator;\n    public readonly value: number;\n    public readonly palette: string;\n\n    public constructor(ddJson: { [opt: string]: string | number }) {\n        this.comparator = ddJson.comparator as Comparator;\n        this.value = ddJson.value as number;\n        this.palette = ddJson.palette as string;\n    }\n\n    public toTerraform(): string {\n        return (\n            'conditional_formats {comparator =' +\n            ` \"${this.comparator}\" value = \"${this.value}\" palette = \"${this.palette}\"}`\n        );\n    }\n}\n","export abstract class BaseComponent {\n    public readonly options: { [opt: string]: string | number | boolean };\n\n    protected readonly ddJson: { [key: string]: any };\n\n    protected constructor(ddJson: { [key: string]: any }) {\n        this.ddJson = ddJson;\n\n        this.options = this.initOptions();\n    }\n\n    /**\n     * Initialise the supported options.\n     */\n    private initOptions(): { [key: string]: string | number | boolean } {\n        const opts: { [key: string]: string | number | boolean } = {};\n        for (const opt of Object.keys(this.ddJson)) {\n            if (this.ddJson.hasOwnProperty(opt) && !this.propertyNames().includes(opt)) {\n                opts[opt] = this.ddJson[opt];\n            }\n        }\n        return opts;\n    }\n\n    /**\n     * Get a list of options that are properties. These will not be added to {this.options}.\n     */\n    protected abstract propertyNames(): string[];\n\n    public toTerraform(): string {\n        const optionList: string[] = [];\n        for (const opt of Object.keys(this.options)) {\n            optionList.push(`${this.optionToTerraform(opt)}`);\n        }\n        return optionList.join(' ');\n    }\n\n    private optionToTerraform(opt: string): string {\n        const value = this.options[opt];\n        if (typeof value === 'boolean') {\n            return `${opt} = ${this.options[opt]}`;\n        }\n        return `${opt} = \"${this.options[opt]}\"`;\n    }\n}\n","import { BaseComponent } from './BaseComponent';\nimport { Request } from './Request';\n\nexport enum WidgetType {\n    ALERT_GRAPH = 'alert_graph',\n    FREE_TEXT = 'free_text',\n    GROUP = 'group',\n    HOSTMAP = 'hostmap',\n    TOPLIST = 'toplist',\n    QUERY_VALUE = 'query_value',\n    TIMESERIES = 'timeseries'\n}\n\nconst TERRAFORM_DEFINITION = {\n    [WidgetType.ALERT_GRAPH]: 'alert_graph_definition',\n    [WidgetType.FREE_TEXT]: 'free_text_definition',\n    [WidgetType.GROUP]: 'group_definition',\n    [WidgetType.HOSTMAP]: 'hostmap_definition',\n    [WidgetType.TOPLIST]: 'toplist_definition',\n    [WidgetType.QUERY_VALUE]: 'query_value_definition',\n    [WidgetType.TIMESERIES]: 'timeseries_definition'\n};\n\nclass Layout {\n    public readonly x: bigint;\n    public readonly y: bigint;\n    public readonly width: bigint;\n    public readonly height: bigint;\n\n    constructor(ddJson: any) {\n        this.x = ddJson.x;\n        this.y = ddJson.y;\n        this.width = ddJson.width;\n        this.height = ddJson.height;\n    }\n\n    public toTerraform(): string {\n        return `layout = {x = ${this.x} y = ${this.y} width = ${this.width} height = ${this.height}}`;\n    }\n}\n\nclass Time extends BaseComponent {\n    protected propertyNames(): string[] {\n        return [];\n    }\n\n    toTerraform(): string {\n        return `time = {${super.toTerraform()}}`;\n    }\n}\n\nexport class Widget extends BaseComponent {\n    public readonly type: WidgetType;\n    public readonly title: string;\n    public readonly layout: Layout | undefined;\n    public readonly requests: Request[];\n    public readonly isSupported: boolean;\n    public readonly widgets: Widget[];\n    public readonly time?: Time;\n\n    private readonly widgetJson: any;\n\n    public constructor(ddJson: any) {\n        super(ddJson.definition);\n\n        this.widgetJson = ddJson;\n        this.type = ddJson.definition.type;\n        this.isSupported = Object.values(WidgetType).includes(ddJson.definition.type);\n        this.title = ddJson.definition.title;\n\n        this.layout = this.initLayout();\n        this.requests = this.initRequests();\n        this.widgets = this.initWidgets();\n        this.time = ddJson.definition.time ? new Time(ddJson.definition.time) : undefined;\n\n        this.validate();\n    }\n\n    private initLayout(): Layout | undefined {\n        if (this.widgetJson.layout !== undefined) {\n            return new Layout(this.widgetJson.layout);\n        }\n        return undefined;\n    }\n\n    private initRequests(): Request[] {\n        if (this.widgetJson.definition.requests instanceof Array) {\n            return this.widgetJson.definition.requests.map((rJson: any) => {\n                return new Request(rJson);\n            });\n        } else if (this.widgetJson.definition.requests !== undefined) {\n            return [new Request(this.widgetJson.definition.requests)];\n        }\n        return [];\n    }\n\n    private initWidgets(): Widget[] {\n        if (this.widgetJson.definition.widgets !== undefined) {\n            return this.widgetJson.definition.widgets.map((wJson: any) => {\n                return new Widget(wJson);\n            });\n        }\n        return [];\n    }\n\n    private validate(): void {\n        if (this.type === WidgetType.GROUP && this.widgets.length === 0) {\n            throw new Error('A group widget must have at least one widget within it.');\n        }\n    }\n\n    protected propertyNames(): string[] {\n        return ['requests', 'title', 'time', 'type', 'widgets'];\n    }\n\n    public toTerraform(): string {\n        let terraformStr = this.title ? `title = \"${this.title}\"` : '';\n        const optionsStr = super.toTerraform();\n        if (optionsStr.length > 0) {\n            terraformStr += ` ${optionsStr}`;\n        }\n        if (this.requests.length > 0) {\n            const requestStr = this.requests\n                .map((req: Request) => {\n                    return req.toTerraform();\n                })\n                .join(' ');\n            terraformStr += ` ${requestStr}`;\n        }\n        if (this.time) {\n            terraformStr += this.time.toTerraform();\n        }\n        const layoutStr = this.layout !== undefined ? ` ${this.layout.toTerraform()}` : '';\n        return `widget {${TERRAFORM_DEFINITION[this.type]} {${terraformStr}${this.widgetsToTerraform()}}${layoutStr}}`;\n    }\n\n    private widgetsToTerraform(): string {\n        if (this.widgets.length > 0) {\n            return (\n                ' ' +\n                this.widgets\n                    .map((wg: Widget) => {\n                        return wg.toTerraform();\n                    })\n                    .join(' ')\n            );\n        }\n        return '';\n    }\n}\n","import { ConditionalFormat } from './ConditionalFormat';\nimport { BaseComponent } from './BaseComponent';\n\nclass Metadata {\n    public readonly expression: string;\n    public readonly aliasName: string;\n\n    constructor(ddJson: { [opt: string]: string }) {\n        this.expression = ddJson.expression;\n        this.aliasName = ddJson.alias_name;\n    }\n\n    public toTerraform(): string {\n        return `metadata {expression = \"${this.expression}\" alias_name = \"${this.aliasName}\"}`;\n    }\n}\n\nclass Style {\n    public readonly palette: string;\n    public readonly lineType: string;\n    public readonly lineWidth: string;\n\n    constructor(ddJson: { [opt: string]: string }) {\n        this.palette = ddJson.palette;\n        this.lineType = ddJson.line_type;\n        this.lineWidth = ddJson.line_width;\n    }\n\n    public toTerraform(): string {\n        let terraformStr = `palette = \"${this.palette}\"`;\n        if (this.lineType) {\n            terraformStr += ` line_type = \"${this.lineType}\"`;\n        }\n        if (this.lineType) {\n            terraformStr += ` line_width = \"${this.lineWidth}\"`;\n        }\n        return `style {${terraformStr}}`;\n    }\n}\n\nexport class Request extends BaseComponent {\n    public readonly query: string;\n    public readonly conditionalFormat: ConditionalFormat[];\n    public readonly metadata: Metadata[];\n    public readonly style: Style | undefined;\n\n    private readonly requestDdJson: { [opt: string]: any };\n\n    public constructor(ddJson: { [opt: string]: any }) {\n        super(ddJson);\n\n        this.requestDdJson = ddJson;\n        this.query = ddJson.fill !== undefined ? ddJson.fill.q : ddJson.q;\n        this.conditionalFormat = this.initConditionalFormat();\n        this.metadata = this.initMetadata();\n        this.style = this.initStyle();\n    }\n\n    private initConditionalFormat(): ConditionalFormat[] {\n        if (this.requestDdJson.conditional_formats !== undefined) {\n            return this.requestDdJson.conditional_formats.map((cfJson: {}) => {\n                return new ConditionalFormat(cfJson);\n            });\n        }\n        return [];\n    }\n\n    private initMetadata(): Metadata[] {\n        if (this.requestDdJson.metadata !== undefined) {\n            return this.requestDdJson.metadata.map((mdJson: {}) => {\n                return new Metadata(mdJson);\n            });\n        }\n        return [];\n    }\n\n    private initStyle(): Style | undefined {\n        if (this.requestDdJson.style !== undefined) {\n            return new Style(this.requestDdJson.style);\n        }\n        return undefined;\n    }\n\n    protected propertyNames(): string[] {\n        return ['q', 'conditional_formats', 'style', 'metadata'];\n    }\n\n    public toTerraform(): string {\n        return (\n            `request {q = \"${this.query}\"${this.optionsToTerraform()}${this.metadataToTerraform()}` +\n            `${this.styleToTerraform()}${this.conditionalFormatToTerraform()}}`\n        );\n    }\n\n    private optionsToTerraform(): string {\n        const optionsStr = super.toTerraform();\n        return optionsStr.length > 0 ? ` ${optionsStr}` : '';\n    }\n\n    private metadataToTerraform(): string {\n        if (this.metadata.length > 0) {\n            return (\n                ' ' +\n                this.metadata\n                    .map((md: Metadata) => {\n                        return md.toTerraform();\n                    })\n                    .join(' ')\n            );\n        }\n        return '';\n    }\n\n    private styleToTerraform(): string {\n        if (this.style) {\n            return ' ' + this.style?.toTerraform();\n        }\n        return '';\n    }\n\n    private conditionalFormatToTerraform(): string {\n        if (this.conditionalFormat.length > 0) {\n            return (\n                ' ' +\n                this.conditionalFormat\n                    .map((cf: ConditionalFormat) => {\n                        return cf.toTerraform();\n                    })\n                    .join(' ')\n            );\n        }\n        return '';\n    }\n}\n","import { Widget } from './Widget';\nimport { BaseComponent } from './BaseComponent';\n\nexport enum LayoutType {\n    FREE = 'free',\n    ORDERED = 'ordered'\n}\n\nexport class Dashboard extends BaseComponent {\n    public readonly layoutType: LayoutType;\n    public readonly notifyList: [string];\n    public readonly widgets: Widget[];\n\n    public constructor(jsonStr: string) {\n        super(JSON.parse(jsonStr));\n\n        this.layoutType = this.ddJson.layout_type;\n        this.notifyList = this.ddJson.notify_list;\n        this.widgets = this.initWidgets();\n    }\n\n    private initWidgets(): Widget[] {\n        if (this.ddJson.widgets) {\n            return this.ddJson.widgets.map((dgWidgetJson: { [opt: string]: any }) => {\n                return new Widget(dgWidgetJson);\n            });\n        }\n        return [];\n    }\n\n    protected propertyNames(): string[] {\n        return ['layout_type', 'notify_list', 'widgets', 'dashboard_id'];\n    }\n\n    public toTerraform(): string {\n        let terraformStr = `layout_type = \"${this.layoutType}\"`;\n        if (this.notifyList !== undefined) {\n            terraformStr += ` notify_list = [${this.notifyList\n                .map((value: string) => {\n                    return `\"${value}\"`;\n                })\n                .join(' ')}]`;\n        }\n        if (this.widgets.length > 0) {\n            terraformStr +=\n                ' ' +\n                this.widgets\n                    .map((wg: Widget) => {\n                        return wg.toTerraform();\n                    })\n                    .join(' ');\n        }\n        return `resource \"datadog_dashboard\" \"dashboard\" {${super.toTerraform()} ${terraformStr}}`;\n    }\n}\n","export class TFPrettier {\n    private readonly indent: number;\n\n    private prettySlr = '';\n    private prevTfChar = '';\n    private curTfChar = '';\n    private inString = false;\n    private bracketLevel = 1;\n\n    constructor(indent?: number) {\n        this.indent = indent || 0;\n    }\n\n    public pretty(tfStr: string): string {\n        for (let tfPos = 0; tfPos < tfStr.length; tfPos++) {\n            this.prevTfChar = this.curTfChar;\n            this.curTfChar = tfStr[tfPos];\n            if (this.curTfChar === '\"' && this.prevTfChar !== '\\\\') {\n                this.inString = !this.inString;\n            }\n            this.prettySlr += this.formatBrackets();\n        }\n        return this.prettySlr;\n    }\n\n    private formatBrackets(): string {\n        if (!this.inString) {\n            if (this.curTfChar === '{') {\n                const formattedStr = `${this.curTfChar}\\n${this.getIndent(this.bracketLevel)}`;\n                this.bracketLevel++;\n                return formattedStr;\n            } else if (this.curTfChar === '}') {\n                this.bracketLevel--;\n                let formattedStr = `${this.curTfChar}\\n`;\n                if (this.bracketLevel > 1) {\n                    formattedStr = `${this.getIndent(this.bracketLevel - 1)}${formattedStr}`;\n                }\n                if (this.prevTfChar !== '}') {\n                    formattedStr = `\\n${formattedStr}`;\n                }\n                return formattedStr;\n            }\n        }\n        return this.curTfChar;\n    }\n\n    private getIndent(level: number): string {\n        if (this.indent > 0) {\n            return ' ' + Array(this.indent * level).join(' ');\n        }\n        return '';\n    }\n}\n","import React from 'react';\nimport CopyToClipboard from 'react-copy-to-clipboard';\n\nimport './App.scss';\nimport { Dashboard } from '../convertor/dashboard/Dashboard';\nimport { TFPrettier } from '../convertor/formatter';\n\nexport interface AppProps {\n    jsonStr?: string;\n}\n\nexport interface AppState {\n    jsonStr: string;\n    terraformStr?: string;\n    error?: string;\n    prettyPrint: boolean;\n}\n\nexport class App extends React.PureComponent<AppProps, AppState> {\n    constructor(props: AppProps) {\n        super(props);\n        this.state = {\n            jsonStr: props.jsonStr || '',\n            prettyPrint: true\n        };\n    }\n\n    public render = (): object => {\n        return (\n            <div className=\"app\">\n                <div className=\"dd-input dd-input-json\">\n                    <label htmlFor=\"dd-json\">Datadog JSON</label>\n                    <textarea\n                        id=\"dd-json\"\n                        className=\"dd-textarea dd-json\"\n                        rows={15}\n                        onChange={this.onJSONChange}\n                        value={this.state.jsonStr}\n                    />\n                    <span id=\"dd-json-error\" className=\"dd-error dd-json-error\">\n                        {this.state.error}\n                    </span>\n                </div>\n                <div className=\"dd-input dd-input-terraform\">\n                    <label htmlFor=\"dd-terraform\">Datadog Terraform</label>\n                    <div className=\"dd-terraform-pretty-print-div\">\n                        <label htmlFor=\"dd-terraform-pretty-print\">Pretty print</label>\n                        <input\n                            type=\"checkbox\"\n                            id=\"dd-terraform-pretty-print\"\n                            checked={this.state.prettyPrint}\n                            onChange={this.onPrettyPrint()}\n                        />\n                    </div>\n                    <pre id=\"dd-terraform\" className=\"dd-terraform\">\n                        {this.state.terraformStr}\n                    </pre>\n                    <CopyToClipboard text={this.state.terraformStr || ''}>\n                        <button id=\"btn-copy-terraform\" title=\"Copy\">\n                            Copy\n                        </button>\n                    </CopyToClipboard>\n                </div>\n            </div>\n        );\n    };\n\n    private onJSONChange = (e: React.FormEvent<HTMLTextAreaElement>): void => {\n        const jsonFldStr = (e.target as HTMLInputElement).value;\n        this.setState({ jsonStr: jsonFldStr }, () => {\n            this.convert();\n        });\n    };\n\n    private convert(): void {\n        const ddJsonStr = this.state.jsonStr;\n        try {\n            const dashboard = new Dashboard(ddJsonStr);\n            const tfStr = dashboard.toTerraform();\n            const formatter = new TFPrettier(2);\n\n            this.setState({ terraformStr: this.state.prettyPrint ? formatter.pretty(tfStr) : tfStr, error: '' });\n        } catch (err) {\n            this.setState({ error: err.message });\n        }\n    }\n\n    private onPrettyPrint = () => {\n        return (): void => {\n            this.setState({ prettyPrint: !this.state.prettyPrint }, () => {\n                this.convert();\n            });\n        };\n    };\n}\n","// This optional code is used to register a service worker.\n// register() is not called by default.\n\n// This lets the app load faster on subsequent visits in production, and gives\n// it offline capabilities. However, it also means that developers (and users)\n// will only see deployed updates on subsequent visits to a page, after all the\n// existing tabs open on the page have been closed, since previously cached\n// resources are updated in the background.\n\n// To learn more about the benefits of this model and instructions on how to\n// opt-in, read https://bit.ly/CRA-PWA\n\nconst isLocalhost = Boolean(\n    window.location.hostname === 'localhost' ||\n        // [::1] is the IPv6 localhost address.\n        window.location.hostname === '[::1]' ||\n        // 127.0.0.1/8 is considered localhost for IPv4.\n        window.location.hostname.match(/^127(?:\\.(?:25[0-5]|2[0-4][0-9]|[01]?[0-9][0-9]?)){3}$/)\n);\n\ntype Config = {\n    onSuccess?: (registration: ServiceWorkerRegistration) => void;\n    onUpdate?: (registration: ServiceWorkerRegistration) => void;\n};\n\nexport function register(config?: Config) {\n    if (process.env.NODE_ENV === 'production' && 'serviceWorker' in navigator) {\n        // The URL constructor is available in all browsers that support SW.\n        const publicUrl = new URL((process as { env: { [key: string]: string } }).env.PUBLIC_URL, window.location.href);\n        if (publicUrl.origin !== window.location.origin) {\n            // Our service worker won't work if PUBLIC_URL is on a different origin\n            // from what our page is served on. This might happen if a CDN is used to\n            // serve assets; see https://github.com/facebook/create-react-app/issues/2374\n            return;\n        }\n\n        window.addEventListener('load', () => {\n            const swUrl = `${process.env.PUBLIC_URL}/service-worker.js`;\n\n            if (isLocalhost) {\n                // This is running on localhost. Let's check if a service worker still exists or not.\n                checkValidServiceWorker(swUrl, config);\n\n                // Add some additional logging to localhost, pointing developers to the\n                // service worker/PWA documentation.\n                navigator.serviceWorker.ready.then(() => {\n                    console.log(\n                        'This web app is being served cache-first by a service ' +\n                            'worker. To learn more, visit https://bit.ly/CRA-PWA'\n                    );\n                });\n            } else {\n                // Is not localhost. Just register service worker\n                registerValidSW(swUrl, config);\n            }\n        });\n    }\n}\n\nfunction registerValidSW(swUrl: string, config?: Config) {\n    navigator.serviceWorker\n        .register(swUrl)\n        .then(registration => {\n            registration.onupdatefound = () => {\n                const installingWorker = registration.installing;\n                if (installingWorker == null) {\n                    return;\n                }\n                installingWorker.onstatechange = () => {\n                    if (installingWorker.state === 'installed') {\n                        if (navigator.serviceWorker.controller) {\n                            // At this point, the updated precached content has been fetched,\n                            // but the previous service worker will still serve the older\n                            // content until all client tabs are closed.\n                            console.log(\n                                'New content is available and will be used when all ' +\n                                    'tabs for this page are closed. See https://bit.ly/CRA-PWA.'\n                            );\n\n                            // Execute callback\n                            if (config && config.onUpdate) {\n                                config.onUpdate(registration);\n                            }\n                        } else {\n                            // At this point, everything has been precached.\n                            // It's the perfect time to display a\n                            // \"Content is cached for offline use.\" message.\n                            console.log('Content is cached for offline use.');\n\n                            // Execute callback\n                            if (config && config.onSuccess) {\n                                config.onSuccess(registration);\n                            }\n                        }\n                    }\n                };\n            };\n        })\n        .catch(error => {\n            console.error('Error during service worker registration:', error);\n        });\n}\n\nfunction checkValidServiceWorker(swUrl: string, config?: Config) {\n    // Check if the service worker can be found. If it can't reload the page.\n    fetch(swUrl)\n        .then(response => {\n            // Ensure service worker exists, and that we really are getting a JS file.\n            const contentType = response.headers.get('content-type');\n            if (response.status === 404 || (contentType != null && contentType.indexOf('javascript') === -1)) {\n                // No service worker found. Probably a different app. Reload the page.\n                navigator.serviceWorker.ready.then(registration => {\n                    registration.unregister().then(() => {\n                        window.location.reload();\n                    });\n                });\n            } else {\n                // Service worker found. Proceed as normal.\n                registerValidSW(swUrl, config);\n            }\n        })\n        .catch(() => {\n            console.log('No internet connection found. App is running in offline mode.');\n        });\n}\n\nexport function unregister() {\n    if ('serviceWorker' in navigator) {\n        navigator.serviceWorker.ready.then(registration => {\n            registration.unregister();\n        });\n    }\n}\n","import React from 'react';\nimport ReactDOM from 'react-dom';\n\nimport { App } from './components/App';\nimport * as serviceWorker from './serviceWorker';\n\nReactDOM.render(<App />, document.getElementById('root'));\n\n// If you want your app to work offline and load faster, you can change\n// unregister() to register() below. Note this comes with some pitfalls.\n// Learn more about service workers: https://bit.ly/CRA-PWA\nserviceWorker.unregister();\n"],"sourceRoot":""}